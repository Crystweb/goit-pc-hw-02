## Опис Табличного Шифру зі Стовпчиковою Транспозицією

**Табличний шифр зі стовпчиковою транспозицією** (Columnar Transposition Cipher) — це метод шифрування, який використовує ключове слово для перестановки символів тексту. Ключ визначає порядок, в якому стовпчики таблиці будуть читатися під час шифрування та дешифрування.

### Кроки Шифрування:
1. **Визначення порядку стовпчиків**:
   - Сортуємо букви ключа в алфавітному порядку.
   - Призначаємо кожній букві номер, який визначає порядок читання стовпчиків.
   - У випадку повторюваних букв, порядок визначається їхнім порядком появи у ключі.

2. **Запис тексту в таблицю**:
   - Записуємо текст по рядках у таблицю з кількістю стовпчиків, що дорівнює довжині ключа.
   - Зберігаємо пробіли та розділові знаки як звичайні символи.

3. **Читання стовпчиків у визначеному порядку**:
   - Зчитуємо текст стовпчиками відповідно до порядку, визначеного ключем, щоб сформувати зашифрований текст.

### Кроки Дешифрування:
1. **Визначення порядку стовпчиків**:
   - Використовуємо той самий порядок стовпчиків, що й при шифруванні.

2. **Розподіл зашифрованого тексту по стовпчиках**:
   - Розбиваємо зашифрований текст на стовпчики відповідно до порядку та довжини ключа.

3. **Відновлення оригінального тексту**:
   - Зчитуємо текст по рядках з таблиці, відновлюючи оригінальний текст.

## Реалізація на Python

Нижче наведено повний код для шифрування та дешифрування тексту за допомогою табличного шифру зі стовпчиковою транспозицією з ключем "SECRET".

```python
import math

def generate_order(key):
    key = key.upper()
    sorted_key = sorted([(char, idx) for idx, char in enumerate(key)], key=lambda x: (x[0], x[1]))
    order = {}
    current_order = 1
    for char, idx in sorted_key:
        order[idx] = current_order
        current_order += 1
    ordered_columns = sorted(order, key=lambda x: order[x])
    return ordered_columns

def encrypt_columnar_transposition(plaintext, key):
    key = key.upper()
    order = generate_order(key)
    key_length = len(key)
    ciphertext = [''] * key_length
    
    for idx, char in enumerate(plaintext):
        column = idx % key_length
        ciphertext[column] += char
    
    encrypted_text = ''.join([ciphertext[idx] for idx in order])
    
    return encrypted_text

def decrypt_columnar_transposition(ciphertext, key):
    key = key.upper()
    order = generate_order(key)
    key_length = len(key)
    num_of_rows = math.ceil(len(ciphertext) / key_length)
    num_full_columns = len(ciphertext) % key_length
    
    column_lengths = {}
    for idx in order:
        if num_full_columns == 0 or idx < num_full_columns:
            column_lengths[idx] = num_of_rows
        else:
            column_lengths[idx] = num_of_rows - 1
    
    columns = {}
    pointer = 0
    for idx in order:
        length = column_lengths[idx]
        columns[idx] = ciphertext[pointer:pointer+length]
        pointer += length
    
    plaintext = ''
    for i in range(num_of_rows):
        for j in range(key_length):
            if i < len(columns[j]):
                plaintext += columns[j][i]
    
    return plaintext

def main_level1():
    print("=== Рівень 1: Табличний шифр зі стовпчиковою транспозицією ===\n")
    
    key = "SECRET"
    print(f"Ключ: {key}\n")
    
    plaintext = input("Введіть текст для шифрування: ")
    
    ciphertext = encrypt_columnar_transposition(plaintext, key)
    print(f"\nЗашифрований текст: {ciphertext}\n")
    
    decrypted_text = decrypt_columnar_transposition(ciphertext, key)
    print(f"Розшифрований текст: {decrypted_text}\n")

if __name__ == "__main__":
    main_level1()
```

## Пояснення Коду

1. **Функція `generate_order(key)`**:
    - Приймає ключове слово та перетворює його у верхній регістр.
    - Сортує букви ключа в алфавітному порядку, враховуючи їхні початкові індекси для повторюваних букв.
    - Призначає кожній букві порядковий номер відповідно до сортування.
    - Повертає список індексів стовпчиків у порядку їх читання.

2. **Функція `encrypt_columnar_transposition(plaintext, key)`**:
    - Перетворює ключ на верхній регістр та визначає порядок стовпчиків.
    - Створює список стовпчиків, де кожен стовпчик представляє собою рядок тексту.
    - Заповнює стовпчики символами тексту по рядках.
    - Зчитує стовпчики у визначеному порядку для формування зашифрованого тексту.
    - Зберігає пробіли та розділові знаки як звичайні символи.

3. **Функція `decrypt_columnar_transposition(ciphertext, key)`**:
    - Перетворює ключ на верхній регістр та визначає порядок стовпчиків.
    - Обчислює кількість рядків у таблиці та визначає, які стовпчики будуть мати на один символ більше (у випадку неповних рядків).
    - Розподіляє зашифрований текст по стовпчиках відповідно до порядку та довжини стовпчиків.
    - Відновлює оригінальний текст, зчитуючи символи по рядках з таблиці.
    - Зберігає пробіли та розділові знаки як звичайні символи.

4. **Функція `main_level1()`**:
    - Виводить заголовок рівня 1.
    - Приймає текст для шифрування від користувача.
    - Шифрує текст за допомогою табличного шифру зі стовпчиковою транспозицією з ключем "SECRET".
    - Виводить зашифрований текст.
    - Дешифрує зашифрований текст для перевірки правильності роботи алгоритму.
    - Виводить розшифрований текст.

## Детальніше про Порядок Стовпчиків

Для ключа "SECRET" порядок стовпчиків визначається наступним чином:

1. **Сортування Букв Ключа**:
   - Ключ: S, E, C, R, E, T
   - Сортування за алфавітом: C, E, E, R, S, T

2. **Призначення Порядкових Номерів**:
   - C (індекс 2) — 1
   - E (індекс 1) — 2
   - E (індекс 4) — 3
   - R (індекс 3) — 4
   - S (індекс 0) — 5
   - T (індекс 5) — 6

3. **Порядок Читання Стовпчиків**:
   - Перший стовпчик — C (індекс 2)
   - Другий стовпчик — E (індекс 1)
   - Третій стовпчик — E (індекс 4)
   - Четвертий стовпчик — R (індекс 3)
   - П'ятий стовпчик — S (індекс 0)
   - Шостий стовпчик — T (індекс 5)

Отже, порядок стовпчиків для шифрування: [2, 1, 4, 3, 0, 5]

## Висновок

Ця програма дозволяє ефективно шифрувати та дешифрувати текст за допомогою табличного шифру зі стовпчиковою транспозицією з ключем "SECRET", зберігаючи пробіли та розділові знаки.