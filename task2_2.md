## Опис Подвійного Табличного Шифру зі Стовпчиковою Транспозицією

**Подвійний табличний шифр зі стовпчиковою транспозицією** — це метод шифрування, який використовує дві різні ключові фрази для двох послідовних перестановок тексту. Спочатку текст зашифровується першим ключем, а потім результат шифрується другим ключем.

### Кроки Шифрування:
1. **Перший Шифр (Ключ "SECRET")**:
   - Використовуємо табличний шифр зі стовпчиковою транспозицією з ключем "SECRET" для першої перестановки тексту.
2. **Другий Шифр (Ключ "CRYPTO")**:
   - Отриманий результат першого шифруємо ще раз за допомогою табличного шифру зі стовпчиковою транспозицією з ключем "CRYPTO".

### Кроки Дешифрування:
1. **Перший Дешифр (Ключ "CRYPTO")**:
   - Спочатку дешифруємо текст за допомогою табличного шифру зі стовпчиковою транспозицією з ключем "CRYPTO".
2. **Другий Дешифр (Ключ "SECRET")**:
   - Потім отриманий результат дешифруємо за допомогою табличного шифру зі стовпчиковою транспозицією з ключем "SECRET".

## Реалізація на Python

Нижче наведено повний Python код для **Рівня 2**, який реалізує подвійний табличний шифр зі стовпчиковою транспозицією з ключами "SECRET" та "CRYPTO".

### Основні Функції:

1. **`generate_order(key)`**: Визначає порядок стовпчиків на основі ключа.
2. **`encrypt_columnar_transposition(plaintext, key)`**: Шифрує текст за допомогою стовпчикової транспозиції.
3. **`decrypt_columnar_transposition(ciphertext, key)`**: Дешифрує текст за допомогою стовпчикової транспозиції.
4. **`double_transposition_encrypt(plaintext, key1, key2)`**: Виконує подвійне шифрування.
5. **`double_transposition_decrypt(ciphertext, key1, key2)`**: Виконує подвійне дешифрування.

### Повний Код:

```python
import math

def generate_order(key):
    key = key.upper()

    key_letters = list(key)
    indexed_key = list(enumerate(key_letters))
    sorted_key = sorted(indexed_key, key=lambda x: (x[1], x[0]))
    order = [idx for idx, char in sorted_key]
    return order

def encrypt_columnar_transposition(plaintext, key):
    key = key.upper()
    order = generate_order(key)
    key_length = len(key)
    ciphertext = [''] * key_length
    
    for idx, char in enumerate(plaintext):
        column = idx % key_length
        ciphertext[column] += char
    
    encrypted_text = ''.join([ciphertext[idx] for idx in order])
    
    return encrypted_text

def decrypt_columnar_transposition(ciphertext, key):
    key = key.upper()
    order = generate_order(key)
    key_length = len(key)
    num_of_rows = math.ceil(len(ciphertext) / key_length)
    num_full_columns = len(ciphertext) % key_length
    
    column_lengths = {}
    for idx in order:
        if num_full_columns == 0 or idx < num_full_columns:
            column_lengths[idx] = num_of_rows
        else:
            column_lengths[idx] = num_of_rows - 1
    
    columns = {}
    pointer = 0
    for idx in order:
        length = column_lengths[idx]
        columns[idx] = ciphertext[pointer:pointer+length]
        pointer += length
    
    plaintext = ''
    for i in range(num_of_rows):
        for j in range(key_length):
            if i < len(columns[j]):
                plaintext += columns[j][i]
    
    return plaintext

def double_transposition_encrypt(plaintext, key1, key2):

    first_encryption = encrypt_columnar_transposition(plaintext, key1)
    second_encryption = encrypt_columnar_transposition(first_encryption, key2)
    return second_encryption

def double_transposition_decrypt(ciphertext, key1, key2):
    first_decryption = decrypt_columnar_transposition(ciphertext, key2)
    second_decryption = decrypt_columnar_transposition(first_decryption, key1)
    return second_decryption

def main_level2():
    print("=== Рівень 2: Подвійний табличний шифр зі стовпчиковою транспозицією ===\n")
    
    key1 = "SECRET"
    key2 = "CRYPTO"
    print(f"Перший ключ (для першої транспозиції): {key1}")
    print(f"Другий ключ (для другої транспозиції): {key2}\n")
    
    plaintext = input("Введіть текст для шифрування: ")
    
    ciphertext = double_transposition_encrypt(plaintext, key1, key2)
    print(f"\nЗашифрований текст після подвійної транспозиції: {ciphertext}\n")
    
    decrypted_text = double_transposition_decrypt(ciphertext, key1, key2)
    print(f"Розшифрований текст: {decrypted_text}\n")

def main():
    print("Виберіть рівень:")
    print("1. Табличний шифр зі стовпчиковою транспозицією (Ключ: SECRET)")
    print("2. Подвійний табличний шифр зі стовпчиковою транспозицією (Ключі: SECRET та CRYPTO)")
    choice = input("Введіть 1 або 2: ")
    
    if choice == '1':
        print("\n=== Рівень 1: Табличний шифр зі стовпчиковою транспозицією ===\n")
        key = "SECRET"
        print(f"Ключ: {key}\n")
        
        plaintext = input("Введіть текст для шифрування: ")
        
        ciphertext = encrypt_columnar_transposition(plaintext, key)
        print(f"\nЗашифрований текст: {ciphertext}\n")
        
        decrypted_text = decrypt_columnar_transposition(ciphertext, key)
        print(f"Розшифрований текст: {decrypted_text}\n")
    
    elif choice == '2':
        main_level2()
    else:
        print("Невірний вибір. Завершення програми.")

if __name__ == "__main__":
    main()
```

## Пояснення Коду:

1. **Функція `generate_order(key)`**:
   - Приймає ключове слово та перетворює його в верхній регістр.
   - Створює список букв з їхніми індексами.
   - Сортує букви ключа в алфавітному порядку, враховуючи їхні початкові індекси для повторюваних букв.
   - Призначає кожній букві порядковий номер відповідно до сортування.
   - Повертає список індексів стовпчиків у порядку їх читання.

2. **Функція `encrypt_columnar_transposition(plaintext, key)`**:
   - Перетворює ключ на верхній регістр та визначає порядок стовпчиків.
   - Створює список стовпчиків, де кожен стовпчик представляє собою рядок тексту.
   - Заповнює стовпчики символами тексту по рядках.
   - Зчитує стовпчики у визначеному порядку для формування зашифрованого тексту.
   - Зберігає пробіли та розділові знаки як звичайні символи.

3. **Функція `decrypt_columnar_transposition(ciphertext, key)`**:
   - Перетворює ключ на верхній регістр та визначає порядок стовпчиків.
   - Обчислює кількість рядків у таблиці та визначає, які стовпчики будуть мати на один символ більше (у випадку неповних рядків).
   - Розподіляє зашифрований текст по стовпчиках відповідно до порядку та довжини стовпчиків.
   - Відновлює оригінальний текст, зчитуючи символи по рядках з таблиці.
   - Зберігає пробіли та розділові знаки як звичайні символи.

4. **Функція `double_transposition_encrypt(plaintext, key1, key2)`**:
   - Виконує шифрування тексту двома послідовними транспозиціями: спочатку з ключем `key1`, потім з ключем `key2`.

5. **Функція `double_transposition_decrypt(ciphertext, key1, key2)`**:
   - Виконує дешифрування тексту двома послідовними транспозиціями: спочатку з ключем `key2`, потім з ключем `key1`.

6. **Функція `main_level2()`**:
   - Виводить заголовок рівня 2.
   - Приймає текст для шифрування від користувача.
   - Виконує подвійне шифрування за допомогою ключів "SECRET" та "CRYPTO".
   - Виводить зашифрований текст після подвійної транспозиції.
   - Виконує дешифрування зашифрованого тексту, відновлюючи оригінальний текст.
   - Виводить розшифрований текст.

7. **Функція `main()`**:
   - Запитує у користувача вибір рівня (1 або 2).
   - Викликає відповідну функцію для обробки вибору.


## Детальніше про Порядок Стовпчиків

#### Ключ "SECRET"

1. **Сортування Букв Ключа**:
   - Ключ: S, E, C, R, E, T
   - Сортування за алфавітом: C, E, E, R, S, T

2. **Призначення Порядкових Номерів**:
   - C (індекс 2) — 1
   - E (індекс 1) — 2
   - E (індекс 4) — 3
   - R (індекс 3) — 4
   - S (індекс 0) — 5
   - T (індекс 5) — 6

3. **Порядок Читання Стовпчиків**:
   - Перший стовпчик — C (індекс 2)
   - Другий стовпчик — E (індекс 1)
   - Третій стовпчик — E (індекс 4)
   - Четвертий стовпчик — R (індекс 3)
   - П'ятий стовпчик — S (індекс 0)
   - Шостий стовпчик — T (індекс 5)

#### Ключ "CRYPTO"

1. **Сортування Букв Ключа**:
   - Ключ: C, R, Y, P, T, O
   - Сортування за алфавітом: C, O, P, R, T, Y

2. **Призначення Порядкових Номерів**:
   - C (індекс 0) — 1
   - O (індекс 5) — 2
   - P (індекс 3) — 3
   - R (індекс 1) — 4
   - T (індекс 4) — 5
   - Y (індекс 2) — 6

3. **Порядок Читання Стовпчиків**:
   - Перший стовпчик — C (індекс 0)
   - Другий стовпчик — O (індекс 5)
   - Третій стовпчик — P (індекс 3)
   - Четвертий стовпчик — R (індекс 1)
   - П'ятий стовпчик — T (індекс 4)
   - Шостий стовпчик — Y (індекс 2)

### Важливі Моменти для Коректної Роботи:

1. **Збереження Пробілів та Розділових Знаків**:
   - У цій реалізації пробіли та розділові знаки розглядаються як звичайні символи та включаються у шифр та дешифрований текст.

2. **Коректність Сортування Ключа**:
   - Сортування ключа враховує як алфавітний порядок букв, так і їхні початкові індекси для обробки повторюваних букв.

3. **Обробка Неповних Рядків**:
   - При дешифруванні враховується, що деякі стовпчики можуть мати на один символ менше, ніж інші, якщо довжина тексту не кратна довжині ключа.

4. **Гнучкість Ключів**:
   - Ви можете змінювати ключі "SECRET" та "CRYPTO" на будь-які інші ключові фрази, враховуючи, що ключ має бути без пробілів та розділових знаків.


## Висновок

Ця програма дозволяє ефективно шифрувати та дешифрувати текст за допомогою подвійного табличного шифру зі стовпчиковою транспозицією, використовуючи ключі "SECRET" та "CRYPTO". Програма зберігає пробіли та розділові знаки, а також правильно обробляє повторювані букви у ключах.